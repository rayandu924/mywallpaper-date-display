<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Date Display</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: transparent;
      font-family: var(--mw-font-family, 'Inter', sans-serif);
    }

    .container {
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      justify-content: center;
      padding: 20px;
    }

    .day-of-week {
      font-size: var(--day-font-size, 24px);
      font-weight: var(--font-weight, 600);
      font-style: var(--font-style, normal);
      color: var(--text-color, #ffffff);
      opacity: var(--text-opacity, 1);
      letter-spacing: var(--letter-spacing, 0px);
      text-shadow: var(--text-shadow, 2px 2px 10px rgba(0,0,0,0.5));
      text-transform: var(--text-transform, none);
      margin-bottom: 5px;
    }

    .date {
      font-size: var(--date-font-size, 48px);
      font-weight: var(--font-weight, 600);
      font-style: var(--font-style, normal);
      color: var(--text-color, #ffffff);
      opacity: var(--text-opacity, 1);
      letter-spacing: var(--letter-spacing, 0px);
      text-shadow: var(--text-shadow, 2px 2px 10px rgba(0,0,0,0.5));
      text-transform: var(--text-transform, none);
      line-height: 1.1;
    }

    .hidden {
      display: none !important;
    }

    /* Text alignment classes */
    .align-left {
      text-align: left;
      align-items: flex-start;
    }

    .align-center {
      text-align: center;
      align-items: center;
    }

    .align-right {
      text-align: right;
      align-items: flex-end;
    }
  </style>
</head>
<body>
  <div class="container" id="container">
    <div class="day-of-week" id="dayOfWeek"></div>
    <div class="date" id="date"></div>
  </div>

  <script>
    // =====================================================
    // Date Display Widget for MyWallpaper
    // =====================================================

    // Language data for preset languages
    var LANGUAGES = {
      en: {
        days: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
        months: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December']
      },
      fr: {
        days: ['Dimanche', 'Lundi', 'Mardi', 'Mercredi', 'Jeudi', 'Vendredi', 'Samedi'],
        months: ['Janvier', 'Février', 'Mars', 'Avril', 'Mai', 'Juin', 'Juillet', 'Août', 'Septembre', 'Octobre', 'Novembre', 'Décembre']
      },
      de: {
        days: ['Sonntag', 'Montag', 'Dienstag', 'Mittwoch', 'Donnerstag', 'Freitag', 'Samstag'],
        months: ['Januar', 'Februar', 'März', 'April', 'Mai', 'Juni', 'Juli', 'August', 'September', 'Oktober', 'November', 'Dezember']
      },
      es: {
        days: ['Domingo', 'Lunes', 'Martes', 'Miércoles', 'Jueves', 'Viernes', 'Sábado'],
        months: ['Enero', 'Febrero', 'Marzo', 'Abril', 'Mayo', 'Junio', 'Julio', 'Agosto', 'Septiembre', 'Octubre', 'Noviembre', 'Diciembre']
      },
      it: {
        days: ['Domenica', 'Lunedì', 'Martedì', 'Mercoledì', 'Giovedì', 'Venerdì', 'Sabato'],
        months: ['Gennaio', 'Febbraio', 'Marzo', 'Aprile', 'Maggio', 'Giugno', 'Luglio', 'Agosto', 'Settembre', 'Ottobre', 'Novembre', 'Dicembre']
      },
      pt: {
        days: ['Domingo', 'Segunda-feira', 'Terça-feira', 'Quarta-feira', 'Quinta-feira', 'Sexta-feira', 'Sábado'],
        months: ['Janeiro', 'Fevereiro', 'Março', 'Abril', 'Maio', 'Junho', 'Julho', 'Agosto', 'Setembro', 'Outubro', 'Novembro', 'Dezembro']
      },
      ja: {
        days: ['日曜日', '月曜日', '火曜日', '水曜日', '木曜日', '金曜日', '土曜日'],
        months: ['1月', '2月', '3月', '4月', '5月', '6月', '7月', '8月', '9月', '10月', '11月', '12月']
      },
      zh: {
        days: ['星期日', '星期一', '星期二', '星期三', '星期四', '星期五', '星期六'],
        months: ['一月', '二月', '三月', '四月', '五月', '六月', '七月', '八月', '九月', '十月', '十一月', '十二月']
      },
      ko: {
        days: ['일요일', '월요일', '화요일', '수요일', '목요일', '금요일', '토요일'],
        months: ['1월', '2월', '3월', '4월', '5월', '6월', '7월', '8월', '9월', '10월', '11월', '12월']
      },
      ru: {
        days: ['Воскресенье', 'Понедельник', 'Вторник', 'Среда', 'Четверг', 'Пятница', 'Суббота'],
        months: ['Январь', 'Февраль', 'Март', 'Апрель', 'Май', 'Июнь', 'Июль', 'Август', 'Сентябрь', 'Октябрь', 'Ноябрь', 'Декабрь']
      },
      ar: {
        days: ['الأحد', 'الإثنين', 'الثلاثاء', 'الأربعاء', 'الخميس', 'الجمعة', 'السبت'],
        months: ['يناير', 'فبراير', 'مارس', 'أبريل', 'مايو', 'يونيو', 'يوليو', 'أغسطس', 'سبتمبر', 'أكتوبر', 'نوفمبر', 'ديسمبر']
      }
    };

    // DOM elements
    var container = document.getElementById('container');
    var dayOfWeekEl = document.getElementById('dayOfWeek');
    var dateEl = document.getElementById('date');

    // Current settings
    var currentSettings = {};
    var loadedFontUrl = null;
    var customFontStyleEl = null;

    // Get language data based on settings
    function getLanguageData(settings) {
      if (settings.languageMode === 'custom') {
        var customDays = (settings.customDays || '').split(',').map(function(s) { return s.trim(); });
        var customMonths = (settings.customMonths || '').split(',').map(function(s) { return s.trim(); });

        // Validate we have correct number of items
        if (customDays.length < 7) {
          customDays = LANGUAGES.en.days;
        }
        if (customMonths.length < 12) {
          customMonths = LANGUAGES.en.months;
        }

        return { days: customDays, months: customMonths };
      }

      return LANGUAGES[settings.language] || LANGUAGES.en;
    }

    // Format date according to settings
    function formatDate(date, settings, langData) {
      var day = date.getDate();
      var month = date.getMonth();
      var year = date.getFullYear();
      var monthName = langData.months[month];
      var monthShort = monthName.substring(0, 3);

      var format = settings.dateFormat || 'long';

      switch (format) {
        case 'long':
          return monthName + ' ' + day + ', ' + year;
        case 'short':
          return monthShort + ' ' + day + ', ' + year;
        case 'numeric':
          return padZero(day) + '/' + padZero(month + 1) + '/' + year;
        case 'numeric-us':
          return padZero(month + 1) + '/' + padZero(day) + '/' + year;
        case 'iso':
          return year + '-' + padZero(month + 1) + '-' + padZero(day);
        case 'day-month':
          return day + ' ' + monthName;
        case 'month-day':
          return monthName + ' ' + day;
        default:
          return monthName + ' ' + day + ', ' + year;
      }
    }

    function padZero(n) {
      return n < 10 ? '0' + n : n.toString();
    }

    // Load custom font from URL
    // ALWAYS requests network permission for custom fonts via the modal
    // Parses CSS to extract font-family names and updates dropdown options
    async function loadCustomFont(url, fontFamily) {
      if (!url || loadedFontUrl === url) return;

      var api = window.MyWallpaper;

      // Validate URL format
      if (!url.startsWith('http://') && !url.startsWith('https://')) {
        console.error('[DateDisplay] Invalid font URL - must start with http:// or https://');
        return;
      }

      // Extract domain from URL
      var domain = null;
      try {
        var urlObj = new URL(url);
        domain = urlObj.hostname;
      } catch (e) {
        console.error('[DateDisplay] Invalid font URL:', url);
        return;
      }

      // Detect common mistakes with Google Fonts URLs and auto-correct
      if (domain === 'fonts.google.com') {
        // Try to extract font family from the URL and construct correct URL
        var fontMatch = url.match(/family=([^&]+)/);
        if (fontMatch) {
          url = 'https://fonts.googleapis.com/css2?family=' + fontMatch[1] + '&display=swap';
          domain = 'fonts.googleapis.com';
          console.log('[DateDisplay] Corrected Google Fonts URL:', url);
        } else {
          console.error('[DateDisplay] Invalid Google Fonts URL. Use fonts.googleapis.com/css2?family=...');
          return;
        }
      }

      // ALWAYS request network permission for custom fonts
      if (!api || !api.network || !api.network.requestAccess) {
        console.error('[DateDisplay] Network API not available');
        return;
      }

      console.log('[DateDisplay] Requesting network access for:', domain);
      var accessResult = await api.network.requestAccess(domain, 'Charger la police personnalisée depuis ' + domain);

      if (!accessResult.granted) {
        console.warn('[DateDisplay] Network access denied for:', domain);
        return;
      }

      console.log('[DateDisplay] Access granted, fetching font CSS...');

      // Fetch the CSS via the SDK's network proxy
      try {
        console.log('[DateDisplay] Fetching URL:', url);
        var response = await api.network.fetch(url);
        console.log('[DateDisplay] Response received:', {
          ok: response.ok,
          status: response.status,
          statusText: response.statusText,
          hasData: !!response.data,
          dataLength: response.data ? response.data.length : 0
        });

        if (response.ok && response.data) {
          loadedFontUrl = url;

          // Log raw CSS content (first 500 chars)
          console.log('[DateDisplay] CSS content preview (first 500 chars):', response.data.substring(0, 500));

          // Remove previous custom font style
          if (customFontStyleEl) {
            customFontStyleEl.remove();
          }

          customFontStyleEl = document.createElement('style');
          customFontStyleEl.textContent = response.data;
          document.head.appendChild(customFontStyleEl);
          console.log('[DateDisplay] Custom font CSS injected into DOM');

          // Parse CSS to extract all font data and update settings dropdowns
          loadedFontData = parseFontDataFromCSS(response.data);
          console.log('[DateDisplay] Parsed font data:', JSON.stringify(loadedFontData, null, 2));

          // Check API availability
          console.log('[DateDisplay] API check:', {
            hasSettings: !!api.settings,
            hasUpdateOptions: !!(api.settings && api.settings.updateOptions),
            familiesFound: loadedFontData.families.length
          });

          if (loadedFontData.families.length > 0) {
            // Store the extracted family globally so applyStyles can use it
            extractedFontFamily = loadedFontData.families[0];
            console.log('[DateDisplay] Stored extracted family:', extractedFontFamily);

            // Update dropdowns if API is available
            if (api.settings && api.settings.updateOptions) {
              // Update font family dropdown
              var familyOptions = loadedFontData.families.map(function(family) {
                return { label: family, value: family };
              });
              console.log('[DateDisplay] Calling updateOptions for customFontFamily:', familyOptions);
              api.settings.updateOptions('customFontFamily', familyOptions, extractedFontFamily);

              // Update weight dropdown
              updateWeightDropdown(api, extractedFontFamily);

              // Update style dropdown
              updateStyleDropdown(api, extractedFontFamily);
            }

            // IMPORTANT: Apply the font immediately with the correct family name
            var root = document.documentElement;
            var correctFontFamily = '"' + extractedFontFamily + '", sans-serif';
            console.log('[DateDisplay] Applying font-family immediately:', correctFontFamily);
            root.style.setProperty('--mw-font-family', correctFontFamily);
            document.body.style.fontFamily = correctFontFamily;
          } else {
            console.warn('[DateDisplay] Cannot update dropdowns:', {
              familiesFound: loadedFontData.families.length,
              hasSettings: !!api.settings,
              hasUpdateOptions: !!(api.settings && api.settings.updateOptions)
            });
          }
        } else {
          console.error('[DateDisplay] Failed to fetch font CSS:', {
            ok: response.ok,
            status: response.status,
            statusText: response.statusText,
            data: response.data ? response.data.substring(0, 200) : null
          });
        }
      } catch (e) {
        console.error('[DateDisplay] Error fetching font CSS:', e);
        console.error('[DateDisplay] Error stack:', e.stack);
      }
    }

    // Parse @font-face rules from CSS to extract all font properties
    // Returns: { families: [], weights: {family: [weights]}, styles: {family: [styles]}, variants: [] }
    function parseFontDataFromCSS(cssText) {
      console.log('[DateDisplay] parseFontDataFromCSS called, CSS length:', cssText.length);

      var result = {
        families: [],           // Unique font family names
        weights: {},            // { "FontName": ["400", "700", ...] }
        styles: {},             // { "FontName": ["normal", "italic"] }
        stretches: {},          // { "FontName": ["normal", "condensed", ...] }
        variants: [],           // Full variant list: [{ family, weight, style, stretch }]
        formats: {}             // { "FontName": ["woff2", "woff", ...] }
      };
      var seenFamilies = {};
      var seenVariants = {};

      // Extract all @font-face blocks
      var fontFaceBlocks = cssText.match(/@font-face\s*\{[^}]+\}/gi) || [];
      console.log('[DateDisplay] Found @font-face blocks:', fontFaceBlocks.length);

      // Log first block for debugging
      if (fontFaceBlocks.length > 0) {
        console.log('[DateDisplay] First @font-face block:', fontFaceBlocks[0]);
      } else {
        // Try alternative regex for multiline blocks
        console.log('[DateDisplay] No blocks found with standard regex, trying alternative...');
        var altBlocks = cssText.match(/@font-face\s*\{[\s\S]*?\}/gi) || [];
        console.log('[DateDisplay] Alternative regex found:', altBlocks.length, 'blocks');
        if (altBlocks.length > 0) {
          fontFaceBlocks = altBlocks;
          console.log('[DateDisplay] First alt block:', fontFaceBlocks[0]);
        }
      }

      fontFaceBlocks.forEach(function(block, index) {
        console.log('[DateDisplay] Parsing block', index + 1, '/', fontFaceBlocks.length);

        var variant = {
          family: null,
          weight: '400',      // default
          style: 'normal',    // default
          stretch: 'normal',  // default
          formats: []
        };

        // Extract font-family (handle quotes, multiple quotes styles)
        var familyMatch = block.match(/font-family\s*:\s*(['"]?)([^;'"]+)\1/i);
        console.log('[DateDisplay] Block', index + 1, '- familyMatch:', familyMatch);
        if (familyMatch) {
          variant.family = familyMatch[2].trim().replace(/^['"]|['"]$/g, '').trim();
          console.log('[DateDisplay] Block', index + 1, '- extracted family:', variant.family);
        }

        // Skip generic families
        if (!variant.family ||
            ['inherit', 'initial', 'unset', 'serif', 'sans-serif', 'monospace', 'cursive', 'fantasy', 'system-ui'].includes(variant.family.toLowerCase())) {
          console.log('[DateDisplay] Block', index + 1, '- skipping (no family or generic)');
          return;
        }

        // Extract font-weight (can be number or keyword)
        var weightMatch = block.match(/font-weight\s*:\s*([^;}\s]+)/i);
        console.log('[DateDisplay] Block', index + 1, '- weightMatch:', weightMatch);
        if (weightMatch) {
          var w = weightMatch[1].trim().toLowerCase();
          // Convert keywords to numbers
          var weightMap = {
            'thin': '100', 'hairline': '100',
            'extralight': '200', 'extra-light': '200', 'ultralight': '200',
            'light': '300',
            'normal': '400', 'regular': '400',
            'medium': '500',
            'semibold': '600', 'semi-bold': '600', 'demibold': '600',
            'bold': '700',
            'extrabold': '800', 'extra-bold': '800', 'ultrabold': '800',
            'black': '900', 'heavy': '900'
          };
          variant.weight = weightMap[w] || w;
          console.log('[DateDisplay] Block', index + 1, '- extracted weight:', variant.weight);
        }

        // Extract font-style
        var styleMatch = block.match(/font-style\s*:\s*([^;}\s]+)/i);
        console.log('[DateDisplay] Block', index + 1, '- styleMatch:', styleMatch);
        if (styleMatch) {
          variant.style = styleMatch[1].trim().toLowerCase();
          console.log('[DateDisplay] Block', index + 1, '- extracted style:', variant.style);
        }

        // Extract font-stretch
        var stretchMatch = block.match(/font-stretch\s*:\s*([^;}\s]+)/i);
        if (stretchMatch) {
          variant.stretch = stretchMatch[1].trim().toLowerCase();
          console.log('[DateDisplay] Block', index + 1, '- extracted stretch:', variant.stretch);
        }

        console.log('[DateDisplay] Block', index + 1, '- final variant:', variant);

        // Extract formats from src
        var srcMatch = block.match(/src\s*:\s*([^;]+)/i);
        if (srcMatch) {
          var formats = srcMatch[1].match(/format\s*\(\s*['"]?([^'")]+)['"]?\s*\)/gi) || [];
          formats.forEach(function(f) {
            var formatMatch = f.match(/format\s*\(\s*['"]?([^'")]+)/i);
            if (formatMatch) {
              var fmt = formatMatch[1].trim().toLowerCase();
              if (!variant.formats.includes(fmt)) {
                variant.formats.push(fmt);
              }
            }
          });
        }

        // Add to results
        var family = variant.family;

        // Track unique families
        if (!seenFamilies[family]) {
          seenFamilies[family] = true;
          result.families.push(family);
          result.weights[family] = [];
          result.styles[family] = [];
          result.stretches[family] = [];
          result.formats[family] = [];
        }

        // Add weight if not already present
        if (!result.weights[family].includes(variant.weight)) {
          result.weights[family].push(variant.weight);
        }

        // Add style if not already present
        if (!result.styles[family].includes(variant.style)) {
          result.styles[family].push(variant.style);
        }

        // Add stretch if not already present
        if (!result.stretches[family].includes(variant.stretch)) {
          result.stretches[family].push(variant.stretch);
        }

        // Add formats
        variant.formats.forEach(function(fmt) {
          if (!result.formats[family].includes(fmt)) {
            result.formats[family].push(fmt);
          }
        });

        // Track unique variants
        var variantKey = family + '|' + variant.weight + '|' + variant.style + '|' + variant.stretch;
        if (!seenVariants[variantKey]) {
          seenVariants[variantKey] = true;
          result.variants.push({
            family: family,
            weight: variant.weight,
            style: variant.style,
            stretch: variant.stretch
          });
        }
      });

      // Sort weights numerically for each family
      Object.keys(result.weights).forEach(function(family) {
        result.weights[family].sort(function(a, b) {
          return parseInt(a) - parseInt(b);
        });
      });

      return result;
    }

    // Legacy function for backward compatibility
    function parseFontFamiliesFromCSS(cssText) {
      return parseFontDataFromCSS(cssText).families;
    }

    // Weight labels for display
    var WEIGHT_LABELS = {
      '100': 'Thin (100)',
      '200': 'Extra-Light (200)',
      '300': 'Light (300)',
      '400': 'Regular (400)',
      '500': 'Medium (500)',
      '600': 'Semi-Bold (600)',
      '700': 'Bold (700)',
      '800': 'Extra-Bold (800)',
      '900': 'Black (900)'
    };

    // Style labels for display
    var STYLE_LABELS = {
      'normal': 'Normal',
      'italic': 'Italic',
      'oblique': 'Oblique'
    };

    // Current loaded font data (for dynamic dropdowns)
    var loadedFontData = null;

    // The actual font family name extracted from CSS (e.g., "Anurati" not "CustomFont")
    var extractedFontFamily = null;

    // Update font weight dropdown based on available weights for a font family
    function updateWeightDropdown(api, family) {
      console.log('[DateDisplay] updateWeightDropdown called for family:', family);
      console.log('[DateDisplay] loadedFontData:', loadedFontData);
      console.log('[DateDisplay] api.settings:', api.settings);
      console.log('[DateDisplay] api.settings.updateOptions:', api.settings ? api.settings.updateOptions : 'N/A');

      if (!loadedFontData || !api.settings || !api.settings.updateOptions) {
        console.warn('[DateDisplay] updateWeightDropdown - missing requirements');
        return;
      }

      var weights = loadedFontData.weights[family] || [];
      console.log('[DateDisplay] Weights for', family, ':', weights);

      if (weights.length === 0) {
        // No weights found, keep default options
        console.log('[DateDisplay] No weights found for', family, '- keeping defaults');
        return;
      }

      var weightOptions = weights.map(function(w) {
        return {
          label: WEIGHT_LABELS[w] || ('Weight ' + w),
          value: w
        };
      });

      // Find a good default (prefer 400, then 500, then first available)
      var defaultWeight = weights.includes('400') ? '400' :
                          weights.includes('500') ? '500' :
                          weights.includes('600') ? '600' : weights[0];

      console.log('[DateDisplay] Calling updateOptions for customFontWeight:', weightOptions, 'default:', defaultWeight);
      var result = api.settings.updateOptions('customFontWeight', weightOptions, defaultWeight);
      console.log('[DateDisplay] updateOptions result for customFontWeight:', result);
    }

    // Update font style dropdown based on available styles for a font family
    function updateStyleDropdown(api, family) {
      console.log('[DateDisplay] updateStyleDropdown called for family:', family);

      if (!loadedFontData || !api.settings || !api.settings.updateOptions) {
        console.warn('[DateDisplay] updateStyleDropdown - missing requirements');
        return;
      }

      var styles = loadedFontData.styles[family] || [];
      console.log('[DateDisplay] Styles for', family, ':', styles);

      if (styles.length <= 1) {
        // Only one style (or none), reset to default
        var defaultOptions = [{ label: 'Normal', value: 'normal' }];
        console.log('[DateDisplay] Only one style, setting default');
        var result = api.settings.updateOptions('customFontStyle', defaultOptions, 'normal');
        console.log('[DateDisplay] updateOptions result for customFontStyle (default):', result);
        return;
      }

      var styleOptions = styles.map(function(s) {
        return {
          label: STYLE_LABELS[s] || s.charAt(0).toUpperCase() + s.slice(1),
          value: s
        };
      });

      console.log('[DateDisplay] Calling updateOptions for customFontStyle:', styleOptions);
      var result = api.settings.updateOptions('customFontStyle', styleOptions, 'normal');
      console.log('[DateDisplay] updateOptions result for customFontStyle:', result);
    }

    // Update dropdowns when family selection changes
    function onFamilyChange(api, family) {
      if (!loadedFontData) return;

      updateWeightDropdown(api, family);
      updateStyleDropdown(api, family);
    }

    // Load preset font from Google Fonts
    function loadPresetFont(fontName) {
      var fontUrl = 'https://fonts.googleapis.com/css2?family=' + fontName.replace(/ /g, '+') + ':wght@300;400;500;600;700;800&display=swap';

      if (loadedFontUrl === fontUrl) return;
      loadedFontUrl = fontUrl;

      if (customFontStyleEl) {
        customFontStyleEl.remove();
      }

      customFontStyleEl = document.createElement('style');
      customFontStyleEl.textContent = '@import url("' + fontUrl + '");';
      document.head.appendChild(customFontStyleEl);
    }

    // Apply CSS custom properties
    function applyStyles(settings) {
      var root = document.documentElement;
      var api = window.MyWallpaper;

      // Font
      var fontFamily;
      var fontWeight;
      var fontStyle = 'normal';

      if (settings.fontMode === 'custom' && settings.customFontUrl) {
        // Load the custom font (will be skipped if already loaded)
        loadCustomFont(settings.customFontUrl, settings.customFontFamily);

        // Use the EXTRACTED font family (from CSS), not the setting value
        // This is crucial because settings.customFontFamily might still be "CustomFont"
        // while the actual font is "Anurati"
        var actualFamily = extractedFontFamily || settings.customFontFamily || 'sans-serif';
        fontFamily = '"' + actualFamily + '", sans-serif';
        console.log('[DateDisplay] applyStyles using font family:', actualFamily, '(extracted:', extractedFontFamily, ', setting:', settings.customFontFamily, ')');

        // Use custom font weight/style if available, fallback to general settings
        fontWeight = settings.customFontWeight || settings.fontWeight || '600';
        fontStyle = settings.customFontStyle || 'normal';

        // Update dropdowns when family changes (for dynamic weight/style options)
        if (loadedFontData && api && extractedFontFamily) {
          onFamilyChange(api, extractedFontFamily);
        }
      } else {
        // Reset custom font state when switching to preset
        extractedFontFamily = null;
        loadedFontData = null;
        loadedFontUrl = null;

        var presetFont = settings.fontPreset || 'Inter';
        loadPresetFont(presetFont);
        fontFamily = '"' + presetFont + '", sans-serif';
        fontWeight = settings.fontWeight || '600';
      }

      root.style.setProperty('--mw-font-family', fontFamily);
      document.body.style.fontFamily = fontFamily;

      // Font sizes
      root.style.setProperty('--day-font-size', (settings.dayFontSize || 24) + 'px');
      root.style.setProperty('--date-font-size', (settings.dateFontSize || 48) + 'px');
      root.style.setProperty('--font-weight', fontWeight);
      root.style.setProperty('--font-style', fontStyle);

      // Colors and text styling
      root.style.setProperty('--text-color', settings.textColor || '#ffffff');
      root.style.setProperty('--text-opacity', (settings.textOpacity || 100) / 100);
      root.style.setProperty('--letter-spacing', (settings.letterSpacing || 0) + 'px');
      root.style.setProperty('--text-transform', settings.textTransform || 'none');

      // Text shadow
      if (settings.enableShadow) {
        var shadowColor = settings.shadowColor || '#000000';
        var shadowBlur = settings.shadowBlur || 10;
        var shadowX = settings.shadowOffsetX || 2;
        var shadowY = settings.shadowOffsetY || 2;
        root.style.setProperty('--text-shadow', shadowX + 'px ' + shadowY + 'px ' + shadowBlur + 'px ' + shadowColor);
      } else {
        root.style.setProperty('--text-shadow', 'none');
      }

      // Alignment
      container.className = 'container align-' + (settings.textAlign || 'left');
    }

    // Update the display
    function updateDisplay(settings) {
      var now = new Date();
      var langData = getLanguageData(settings);

      // Day of week
      if (settings.showDayOfWeek) {
        dayOfWeekEl.textContent = langData.days[now.getDay()];
        dayOfWeekEl.classList.remove('hidden');
      } else {
        dayOfWeekEl.classList.add('hidden');
      }

      // Date
      if (settings.showDate) {
        dateEl.textContent = formatDate(now, settings, langData);
        dateEl.classList.remove('hidden');
      } else {
        dateEl.classList.add('hidden');
      }
    }

    // Main update function
    function update(settings) {
      currentSettings = settings || currentSettings;
      applyStyles(currentSettings);
      updateDisplay(currentSettings);
    }

    // Initialize when SDK is ready
    async function init() {
      var api = window.MyWallpaper;

      if (!api) {
        console.error('[DateDisplay] MyWallpaper SDK not found');
        return;
      }

      console.log('[DateDisplay] Initializing...');

      // Initial render with current config
      update(api.config);

      // Listen for settings changes (hot reload)
      api.onSettingsChange(function(settings, changedKeys) {
        console.log('[DateDisplay] Settings changed:', changedKeys);
        update(settings);
      });

      // Update every minute to keep the date current (in case it's left open overnight)
      setInterval(function() {
        updateDisplay(currentSettings);
      }, 60000);

      // Signal ready
      api.ready({
        capabilities: ['hot-reload'],
        subscribedEvents: []
      });

      // Wait for fonts to load before signaling render complete
      // This is crucial for thumbnail generation to capture the correct font
      try {
        console.log('[DateDisplay] Waiting for fonts to load...');
        await document.fonts.ready;
        console.log('[DateDisplay] Fonts ready, loaded:', document.fonts.size, 'fonts');

        // Extra wait for custom font CSS to be applied
        if (currentSettings.fontMode === 'custom' && currentSettings.customFontUrl) {
          // Wait a bit more for custom font to render
          await new Promise(resolve => setTimeout(resolve, 500));
          // Try to explicitly load the font if we know the family
          if (extractedFontFamily) {
            try {
              await document.fonts.load('24px "' + extractedFontFamily + '"');
              console.log('[DateDisplay] Custom font explicitly loaded:', extractedFontFamily);
            } catch (e) {
              console.warn('[DateDisplay] Could not explicitly load font:', e);
            }
          }
        }
      } catch (e) {
        console.warn('[DateDisplay] Error waiting for fonts:', e);
      }

      // Signal render complete AFTER fonts are loaded
      api.renderComplete();
      console.log('[DateDisplay] Ready!');
    }

    // Wait for SDK
    if (window.MyWallpaper) {
      init();
    } else {
      window.addEventListener('mywallpaper:ready', init);
      // Fallback timeout
      setTimeout(function() {
        if (window.MyWallpaper && !currentSettings.language) {
          init();
        }
      }, 1000);
    }
  </script>
</body>
</html>
